# Conversation with Ward

2 March 2020

Ward: I reflect on my mechanical translation of Whitehead to federated wiki. Now that I've done it I know how I should have done it and made the whole process easier. However, my somewhat awkward first version engaged @johnbywater who recognized immediately formatting challenges I had missed. Thanks John. Now I turn my attention to what Whitehead actually wrote.

https://github.com/WardCunningham/whitehead/blob/master/README.md

John: Fabulous.

One thing that I haven't paid enough attention to (pulled together very well) is the correspondence between Whiteheads's system and software. There's the match with event sourced DDD that I've mentioned: "domain model -> event-sourced aggregate -> domain event" is an example of "corpuscular society (nexus with many strands of personal order) -> enduring object (nexus with personal order) -> actual occasion". That's really the fish hook I have in my mouth, that's why I got caught on this stuff. It's like DDD is a single room I was living in, and I then I realised there's a whole mansion house to explore.

As I've said before, there are four stages of an actual occasion, which just seems to correspond with the structure of the Alexandrian pattern. And then Alexander's statements in Timeless Way of Building: (a) that he is looking for patterns of events; and (b) that in the end (when you go through the "gate" and pass through a pattern language, the patterns don't matter any longer, because they have taught you to be receptive to what is real. That just seems to tie beautifully back to Whitehead's statement that there is no going behind the actual occasions to find anything more real.

But there are a few other things that I haven't quite pulled into the centre of my attention, and perhaps more if I were to pay more careful attention. And perhaps now I can pay more attention to this. So firstly there is the structure of the book: which is quite definitely iterative (he talks of "recurring" to the topics): and incremental.(he talks of adding something to them with each recursion). Secondly, there is the notion of "concerns" that he says is addressing, which seems to be the same thing as we separate in software, when we work towards a "separation of concerns".

I already mentioned the "atomic" aspect of recording which makes a set of model changes into a "thing": an actual occasion indivisible on the level of its logical unity (the statements in the transaction either all happen or none of them happen), but divisible in its physical actuality (resulting records can be updated or deleted individually). And the way that allows the processing of domain events to be considered atomically, as "process events". Also (bearing in mind Whitehead's proposition that each actual occasion has both a physical and a mental pole) that this "indivisible logical unity" corresponds to the settlement that takes place on the mental pole of an actual occasions, and that the "divisible records" corresponds to the physical pole. (_"The tone of feeling embodied in this satisfaction passes into the world beyond, by reason of these objectifications."_)

There's also the different ways a team can form together. In the end, the HEAD or a tag on some branch is built into a distribution, or directly deployed. But whichever is the latest changeset, and however many other branches there are, there's a single line of changes going back from the point that is released to the initial empty state of the repository. So that's a set of changes with serial ordering, an enduring object with personal order. And by comparison, a team of developers (and other roles) is a corpuscular society. So there are different ways in which the experience of the members of the team (as a corpuscular society) combine to make the working software (an enduring object, with a single strand of personal order). There are the sole or pairs of programmers with feature branches and continuous integration; solo or pairs of programmers doing trunk based development perhaps with feature toggles but with their local branches; and then mob programming with no branches so that their corpuscularity is merged into a personal order whilst the code is being written.

It seems like quite a short list, but I suppose that's already quite a lot. I just thought perhaps by writing this list, beyond gathering these thoughts together for the first time, you might also find things that you notice or recognise as things you've thought or felt or seen before. If so, please let me know what they are!

Oh yes, that's the other thing I remembered and then forgot: the verb "build". I remember the good advice to dispense with the building metaphor and adopt the steering metaphor instead. However, I've aware of going back to Whitehead's phrase "the actual of world is built up of actual occasions". So I think this word 'building' perhaps isn't a metaphor anymore. I know I'm not building a house when developing software, but a house is also built up of actual occasions much more than it's built out of bricks according to a preconceived design. So I started to think it's actually okay to talk about building software, so long as it's understood that the software is built up of actual occasions of software development (the "decisions") and not a matter of pouring concrete into trenches and pushing bricks into cement according to previously documented instructions.

And another thing: I suppose also I've become a bit critical of the Manifesto for Agile Software Development. Most of the "agile hate wave" seems to be analysed as divergence from the truth (people aren't doing "real agile" because they aren't doing it "properly" for various reasons). I think that's fair enough, but I have found myself, from time to time this last year, voicing some criticisms about the manifesto itself: (1) I don't recognise in this manifesto a description that resembles the four stages of an actual occasions (as I did in that passage in EPISODES, and as I do in the Alexandrian form, both of which are actually quite different, and I feel are originally and carefully felt descriptions of the same thing Whitehead was intuiting); (2) the work "creativity" isn't used at all; and (3) the notion of process that figures is not the process of becoming of an actual occasion, but a notion of process which is counter-pointed to interactions ("individuals and interactions over processes and tools") and obviously refers to a formal (perhaps corporate, perhaps rigid or managed, or top-down, or approved) process, which is a form of process which fits with one of the two kinds of flow that Whitehead identifies: the flow from existent to existent.

Regarding the existence of the principles, I'm a little bit unsure what I think. I can recognise the principles as an attempt to say something timeless about software development, to extract the "eternal objects" from the actual occasions of experience of the signatories, so that they might more easily ingress into future actual occasions of software development. But I also remember Whitehead's statement about going from principles to actual occasions: "It is a complete mistake to ask how concrete particular fact can be built up out of universals. The answer is, In no way." This doesn't entirely add up in my mind yet, so I'm not quite settled about that.

The other thing I'm not quite settled about is what I think about the name "agile". I have been feeling that phrases such as "agile team" and "agile project" and "agile developer" and "agile coach" and event perhaps "agile software development" are unhelpful if they pull thinking towards the substance-quality metaphysics that Whitehead describes as misplaced concreteness, as restrictive of thought, and which his system seeks to avoid. However, things like hot tea, cooked food, good sleep, fresh air, a lively fire, a clean floor, etc are all things that I enjoy. So it just seems that "agile team" can be imagined in these two different ways, with one way being perhaps better than the other.

I suppose Whitehead's system is as much about making new things, as it is about making things new.
